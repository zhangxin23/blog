Error Responses
HTTP status codes play an important role in REST APIs. API developers should strive to return the right
codes indicating the request status. Additionally, it is good practice to provide helpful, fine-grained details
regarding the error in the response body. These details will enable API consumers to troubleshoot issues
easily and help them to recover. As you can see in Figure 5-3, Spring Boot follows this practice and includes
the following details in error response bodies:

•	 timestamp—The time in milliseconds when the error happened
•	 status—HTTP status code associated with the error; this is partly redundant as it is
same as the response status code
•	 error—The description associated with the status code
•            exception—The fully qualified path to the exception class resulting in this error
•	 message—The message providing more details about the error
•	 path—The URI that resulted in the exception

Input Field Validation
As a famous proverb goes, “Garbage in Garbage Out”; input field validation should be another area of
emphasis in every application.
Spring MVC provides two options for validating user input. In the first option, we create a validator
that implements the org.springframework.validation.Validator interface. Then we inject this validator
into a controller and invoke validator’s validate method manually to perform validation. The second option
is to use the JSR 303 validation, an API intended to simplify field validation in any layer of the application.
Considering the simplicity and the declarative nature of the framework, we will be using JSR 303 validation
framework in this book.
The JSR 303 and JSR 349 define specifications for the Bean Validation API (version 1.0 and 1.1, respectively).
They provide a metadata model for JavaBean validation via a set of standardized validation constraints. Using
this API, you annotate domain object properties with validation constraints such as @NotNull and @Email.
Implementing frameworks enforce these constraints at runtime. In this book, we will be using Hibernate
Validator, a popular JSR 303/349 implementation framework.

Constraint Description
NotNull Annotated field must not have null value
Null Annotated field must be null
Max Annotated field value must be an integer value lower than or equal to the number specified
in the annotation
Min Annotated field value must be an integer value greater than or equal to the number
specified in the annotation
Past Annotated field must be a date in the past
Future Annotated field must be a date in the future
Size Annotated field must match the min and max boundaries specified in the annotation.
For a field that is a Collection, the size of the Collection is matched against boundaries.
For a String field, the length of the string is verified against boundaries
Pattern Annotated field must match the regular expression specified in the annotation

Externalizing Error Messages
We have made quite a bit of progress with our input validation and provided the client with descriptive error
messages that can help them troubleshoot and recover from those errors. However, the actual validation
error message may not be very descriptive and API developers might want to change it. It would be even
better if they were able to pull this message from an external properties file. The property file approach not
only simplifies Java code but also makes it easy to swap the messages without making code changes. It also
sets the stage for future internationalization/localization needs. To achieve this, create a messages.properties
file under the src\main\resources folder and add the following two messages:
NotEmpty.poll.question=Question is a required field
Size.poll.options=Options must be greater than {2} and less than {1}

As you can see, we are following the convention - <<Constraint_Name>>.model_name.field_Name for
each key of the message.

The next step is to read the properties from the file and use them during the ValidationError instance
creation. We do that by injecting an instance of MessageSource into the RestExceptionHandler class.
Spring’s MessageSource provides an abstraction to easily resolve messages.

Improving RestExceptionHandler
By default, Spring MVC handles error scenarios such as not being able to read a malformed request or not
finding a required request parameter by throwing a set of standard exceptions. However, Spring MVC doesn’t
write these standard exception details to the response body. To keep things consistent for our QuickPoll clients,
it is important that Spring MVC standard exceptions are also handled in the same way and that we return the
same error response format. A straightforward approach is to create a handler method for each exception
in our RestExceptionHandler. A simpler approach is to have RestExceptionHandler class extend Spring’s
ResponseEntityExceptionHandler. The ResponseEntityExceptionHandler class contains a set of protected
methods that handle standard exception and return a ResponseEntity instance containing error details.
Extending the ResponseEntityExceptionHandler class allows us to override the protected
method associated with the exception and return an ErrorDetail instance.